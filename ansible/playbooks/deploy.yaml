---
- hosts: local
  gather_facts: false
  become: false
  vars:
    ssh_known_hosts_file: "{{ lookup('env','HOME') + '/.ssh/known_hosts' }}"
    date_slug_cmd: "{{ lookup('pipe', 'date +%Y%m%d%H%M%S') }}"
    random_string_cmd: "{{ lookup('password', '/dev/null length=10 chars=ascii_letters,digits') }}"
  tasks:
    - name: Set deploy_id
      when: deploy_id is undefined # deploy_id might have been defined using command-line argument
      set_fact:
        deploy_id: "{{ date_slug_cmd }}-{{ random_string_cmd }}"
    - debug:
        msg: "deploy_id is {{ deploy_id }}"
    - name: Build application Achievements
      when: do_build is undefined or do_build|bool
      include_role:
        name: achievements
        tasks_from: build
    - name: Build application Names
      when: do_build is undefined or do_build|bool
      include_role:
        name: names
        tasks_from: build
    - name: Get information about distributions
      uri:
        url: https://api.digitalocean.com/v2/images?page=1&per_page=1000&type=distribution
        method: GET
        headers:
          Authorization: "Bearer {{ digitalocean_api_key }}"
          Content-Type: "application/json"
      register: distributions

#    - name: Print stuff
#      debug:
#        msg: "{{ distributions }}"

    - name: Get slug of latest Ubuntu distribution
      set_fact:
        # Need to_json and from_json to avoid type checking issue. See https://github.com/ansible/ansible/issues/27299#issuecomment-331068246
        digitalocean_image_id: "{{ distributions | to_json | from_json | json_query('sort_by(json.images[?distribution==`Ubuntu` && contains(regions, `'+digitalocean_region+'`) && contains(slug, `x64`)], &slug)[-1].slug') }}"

    - debug:
        msg: "Image slug for newest Ubuntu distribution is {{ digitalocean_image_id }}"

    - name: Get information about existing Droplets
      uri:
        url: https://api.digitalocean.com/v2/droplets
        method: GET
        headers:
          Authorization: "Bearer {{ digitalocean_api_key }}"
          Content-Type: "application/json"
      register: existing_droplets

    - name: Read IP addresses of existing Droplet
      set_fact:
        deploy_id: "{{ deploy_id }}"
        old_droplet_id: "{{ existing_droplets | json_query('json.droplets[0].id') }}"
        old_droplet_ip: "{{ existing_droplets | json_query('json.droplets[0].networks.v4[?type==`private`].ip_address') | first }}"
        old_droplet_ip_public: "{{ existing_droplets | json_query('json.droplets[0].networks.v4[?type==`public`].ip_address') | first }}"
      when: existing_droplets.json.meta.total > 0

    - debug:
        msg: "Internal IP address of pre-existing Droplet (id {{ old_droplet_id }}) is {{ old_droplet_ip }} and the public is {{ old_droplet_ip_public }}"
      when: old_droplet_ip is defined

    # Source: https://stackoverflow.com/a/35213839
    - name: Add SSH fingerprint of old (pre-existing) Droplet to list of known hosts
      shell: "ssh-keyscan {{ old_droplet_ip_public }} >> {{ ssh_known_hosts_file }}"
      when: old_droplet_ip is defined

    - name: Add host for old Droplet
      add_host:
        hostname: "{{ old_droplet_ip_public }}"
        groupname: digitalocean_old
      when: old_droplet_ip is defined

    - name: Create Droplet from image provided by Digital Ocean.
      digital_ocean:
        state: present
        api_token: "{{ digitalocean_api_key }}"
        backups_enabled: no
        image_id: "{{ digitalocean_image_id }}"
        ipv6: no
        name: "default-{{ deploy_id }}"
        unique_name: yes
        private_networking: yes
        region_id: "{{ digitalocean_region }}"
        size_id: "{{ digitalocean_size_id }}"
        ssh_key_ids: "{{ digitalocean_ssh_pub_keys }}"
        wait: yes
        wait_timeout: 300
        user_data: "{{ lookup('template', 'files/initial_server_setup.sh') }}"
      register: do_droplet

    - name: Read id of new Droplet
      set_fact:
        new_droplet_id: "{{ do_droplet.droplet.id }}"
    - name: Wait for SSH to become available
      pause:
        seconds: 30
    # Source: https://stackoverflow.com/a/35213839
    - name: Remove new Droplet's IP address from list of known hosts in case that address has previous been used by other Droplet
      shell: "ssh-keygen -R {{ do_droplet.droplet.networks.v4[1].ip_address }}"

    - name: Add SSH fingerprint of new Droplet to list of known hosts
      shell: "ssh-keyscan {{ do_droplet.droplet.networks.v4[1].ip_address }} >> {{ ssh_known_hosts_file }}"

    - name: Add host for new Droplet
      add_host:
        hostname: "{{ do_droplet.droplet.networks.v4[1].ip_address }}"
        groupname: digitalocean

- hosts: digitalocean
  gather_facts: false
  remote_user: "{{ digitalocean_sudo_user }}"
  become: true
  vars:
    deploy_id: "{{ hostvars[groups['local'][0]].deploy_id }}"
  tasks:
#    - name: Upgrade operating system to latest version. Enable automatic security updates.
    - name: Update package cache
      command: apt update
      become: yes
    - name: Install DigitalOcean Monitoring agent
      include_role:
        name: digitalocean-agent
        tasks_from: install
    - name: Install AWS tooling
      include_role:
        name: aws-tooling
        tasks_from: install
    - name: Install Certbot
      include_role:
        name: certbot
        tasks_from: install
    - name: Install Nginx
      include_role:
        name: nginx
    - name: Install Java
      include_role:
        name: java
    - name: Install PostgreSQL
      include_role:
        name: postgres
    - name: Install Achievements server
      include_role:
        name: achievements
        tasks_from: install
    - name: Install Names server
      include_role:
        name: names
        tasks_from: install
#    - debug:
#        msg: "{{ new_droplet_user_key }}"

- hosts: digitalocean_old
  gather_facts: false
  remote_user: "{{ digitalocean_sudo_user }}"
  become: false
  vars:
    deploy_id: "{{ hostvars[groups['local'][0]].deploy_id }}"
  tasks:
    - name: Install AWS tooling
      include_role:
        name: aws-tooling
        tasks_from: install
    - name: Create database backup
      command: "sudo -u postgres pg_dumpall --username=postgres --file=/tmp/redeploy_backup_{{ deploy_id }}.sql"
      become: yes
    - name: Create Let's Encrypt backup
#      -z: filter the archive through gzip
#      -p: extract information about file permissions (default for superuser)
#      -c: create a new archive
#      -v: verbosely list files
#      -f: archive file
      command: "sudo tar -zpcvf /tmp/redeploy_backup_{{ deploy_id }}_letsencrypt.tar.gz /etc/letsencrypt/"
      become: yes
    - name: Create home directory backup
#      -z: filter the archive through gzip
#      -p: extract information about file permissions (default for superuser)
#      -c: create a new archive
#      -v: verbosely list files
#      -f: archive file
      command: "sudo tar -zpcvf /tmp/redeploy_backup_{{ deploy_id }}_homedirectory.tar.gz /home/{{ digitalocean_sudo_user }}/"
      become: yes
    - name: Upload backups
      command: "sudo aws s3 cp /tmp/ s3://mikaelsvensson.info-digitalocean.deploy/deploy-{{ deploy_id }}/ --recursive --exclude '*' --include 'redeploy_backup_{{ deploy_id }}*'"
      become: yes

- hosts: digitalocean
  gather_facts: false
  remote_user: "{{ digitalocean_sudo_user }}"
  become: true
  vars:
    old_droplet_ip: "{{ hostvars[groups['local'][0]].old_droplet_ip | default('') }}"
    new_droplet_id: "{{ hostvars[groups['local'][0]].new_droplet_id | default('') }}"
    deploy_id: "{{ hostvars[groups['local'][0]].deploy_id }}"
  tasks:
    - name: If other Droplet exists; Fetch backups
      command: "sudo aws s3 cp s3://mikaelsvensson.info-digitalocean.deploy/deploy-{{ deploy_id }}/ /tmp/ --recursive"
      become: yes
      when: old_droplet_ip != ''
    - name: If other Droplet exists; Extract Let's Encrypt backup
      # Source: https://community.letsencrypt.org/t/move-to-another-server/77985/4
      command: "sudo tar -zxvf /tmp/redeploy_backup_{{ deploy_id }}_letsencrypt.tar.gz -C /"
      become: yes
      when: old_droplet_ip != ''
#    - name: If other Droplet exists; Extract home directory backup
#      command: "sudo tar -zxvf /tmp/redeploy_backup_{{ deploy_id }}_homedirectory.tar.gz -C /"
#      become: yes
#      when: old_droplet_ip != ''
    - name: If other Droplet exists; Restore database from backup
      shell: "sudo -u postgres psql -f /tmp/redeploy_backup_{{ deploy_id }}.sql postgres"
      become: yes
      when: old_droplet_ip != ''
    - name: Start Achievements server
      include_role:
        name: achievements
        tasks_from: start
    - name: Start Names server
      include_role:
        name: names
        tasks_from: start
#    - name: Open firewall to allow http, https and ssh to the Droplet.
#    - name: Send status mail
#    - name: If other Droplet exists; Shutdown old Droplet.
#    - name: If other Droplet exists; Take snapshot of old Droplet.
    - name: "Assign floating IP to new Droplet"
      become: no
      digital_ocean_floating_ip:
        state: present
        ip: "{{ digitalocean_floating_ip }}"
        droplet_id: "{{ new_droplet_id }}"
        oauth_token: "{{ digitalocean_api_key }}"
    - name: "Wait for service to become available over http"
      uri:
        url: "http://{{ app_host_name }}"
        timeout: 5
    - name: "Start Certbot for Nginx"
      include_role:
        name: certbot
        tasks_from: start
- hosts: local
  gather_facts: false
  become: false
  vars:
    new_droplet_id: "{{ hostvars[groups['local'][0]].new_droplet_id | default('') }}"
  tasks:
    - name: "Wait for service to become available over https"
      uri:
        url: "https://{{ app_host_name }}"
        timeout: 5
#    - name: Wait for DNS change to be propagated, e.g. by waiting for "TTL seconds" (which I believe is 90 seconds for Dynu DNS names)
    - name: If other Droplet exists; Delete old Droplet.
      when: old_droplet_ip != ''
      digital_ocean:
        state: deleted
        api_token: "{{ digitalocean_api_key }}"
        id: "{{ old_droplet_id }}"
